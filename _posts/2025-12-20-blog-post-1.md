---
title: 'Why Config Files Make You a Better Data Scientist'
date: 2025-12-20
permalink: /posts/2025/12/01-config-files/
tags:
  - Python
  - Time Series Analysis
---

My first Python project had magic numbers everywhere. alpha=2.0 here, alpha=0.15 there... When I needed to change something, it was a nightmare. I had to find where the parameters are located. Sometimes I lost track of them and found inconsistency across the scripts which resulted in breaking the scripts.

A config file, short for "configuration file", is a file comprised of all the parameter settings used in the scripts. Instead of scattered approach, I put them in one place. My sample config file looks like this:

```python
from __future__ import annotations
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict

# Common imports used across all scripts
import pandas as pd
import numpy as np

# ----------------------------
# GLOBAL CONFIGURATION
# ----------------------------
@dataclass
class GlobalConfig:
    """
    Central configuration for the entire forecasting system.
    All scripts import this to ensure consistency.
    """
    # =================================================================
    # BASE DIRECTORIES
    # =================================================================
    project_root: Path = Path(__file__).parent
    data_dir: Path = project_root / "data"
    out_dir: Path = project_root / "output"  
    .....
    .....
    .....
```

### @dataclass decorator
The decorator concept in Python is similar to other programming languages such as C#, TypeScript. Decorators can add and modify behaviors, add functionality, and even enforce rules. @dataclass automatically adds built-in methods to make the code cleaner.

### \_\_post_init\_\_ method
\_\_post_init\_\_ is called a "dunder method" (short for "double underscore") which is a special method that Python calls automatically after \_\_init\_\_ finishes. Think of it as: "Do some extra setup after the object is created". For example, the code below automatically creates output directories if they don't exist 

```python
    def __post_init__(self):
       
        directories = [
            self.out_dir,
            self.forecast_input_parquet.parent,
            self.out_forecast,
            self.out_allocation,
            self.out_cv,
            self.out_03b_cv,
            self.out_targets,
            self.out_final
        ]
        
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
```

### How to use config.py?
In any script, use import
```python
# Import global config and common libraries
from config import global_config as gcfg, pd, np
...
dataset_xlsx: Path = gcfg.dataset_xlsx
dataset_sheet: str = gcfg.dataset_sheet
holidays_xlsx: Path = gcfg.holidays_xlsx
...

```
### The if __name__ == "__main__" guard
This is one of Python's most common patterns. It means that "only run this code if this file is being run directly (not imported)". It's Python's way of separating "Run as a program" (execute the script) from "User as a library" (import functions from it).

What I learned: professional code is about making future changes easy.

